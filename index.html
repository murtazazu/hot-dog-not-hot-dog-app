<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hot Dog / Not Hot Dog</title>
    
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Custom spinner for loading state */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4f46e5;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Container --><div class="w-full max-w-lg bg-white shadow-2xl rounded-xl p-6 md:p-8 space-y-6">

        <!-- Header --><header class="text-center">
            <h1 class="text-4xl md:text-5xl font-extrabold text-gray-900 leading-tight">
                Hot Dog <span class="text-red-600">/</span> Not Hot Dog
            </h1>
            <p class="text-md text-gray-500 mt-2">The future of image classification is here.</p>
        </header>

        <!-- Image Preview Area --><div id="imagePreviewContainer" class="relative w-full h-64 border-4 border-dashed border-gray-300 rounded-lg flex items-center justify-center bg-gray-50 overflow-hidden">
            <img id="previewImage" class="hidden w-full h-full object-cover" alt="Image preview">
            <p id="placeholderText" class="text-gray-500 italic">Select an image to begin...</p>
        </div>

        <!-- File Input and Action Button --><div class="flex flex-col space-y-4">
            <label for="imageUpload" class="block text-sm font-medium text-gray-700">Upload your hot dog (or not hot dog):</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-indigo-50 file:text-indigo-600
                hover:file:bg-indigo-100 cursor-pointer
            " onchange="handleImageSelect()">
            
            <button id="classifyButton" onclick="classifyImage()" 
                class="w-full py-3 px-4 bg-indigo-600 text-white font-bold rounded-full shadow-lg
                hover:bg-indigo-700 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center" disabled>
                <span id="buttonText">CLASSIFY!</span>
                <div id="loadingIndicator" class="spinner ml-3 hidden"></div>
            </button>
        </div>

        <!-- Results Display Area --><div id="resultsArea" class="min-h-[6rem] p-4 rounded-lg text-center transition-all duration-300 hidden">
            <p id="resultText" class="text-3xl font-extrabold"></p>
            <p id="confidenceText" class="text-xl font-semibold mt-2 text-gray-700"></p>
            <p id="errorText" class="text-red-500 font-medium mt-2 hidden"></p>
        </div>

    </div>

    <script type="module">
        // Global constants and variables
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const apiKey = "AIzaSyCSPyinLoN03us7_LmxblNrX0wV9QMuXOQ"; // YOUR API KEY IS INSERTED HERE

        // UI Element references
        const imageUpload = document.getElementById('imageUpload');
        const previewImage = document.getElementById('previewImage');
        const placeholderText = document.getElementById('placeholderText');
        const classifyButton = document.getElementById('classifyButton');
        const buttonText = document.getElementById('buttonText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const resultsArea = document.getElementById('resultsArea');
        const resultText = document.getElementById('resultText');
        const confidenceText = document.getElementById('confidenceText');
        const errorText = document.getElementById('errorText');

        let base64Image = null; // Stores the Base64 data of the selected image

        /**
         * Converts ArrayBuffer to Base64 string.
         * @param {ArrayBuffer} buffer - The buffer to convert.
         * @returns {string} The Base64 encoded string.
         */
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /**
         * Handles image file selection and displays a preview.
         */
        window.handleImageSelect = function() {
            const file = imageUpload.files[0];
            if (!file) {
                previewImage.classList.add('hidden');
                placeholderText.classList.remove('hidden');
                classifyButton.disabled = true;
                base64Image = null;
                resultsArea.classList.add('hidden');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                previewImage.src = e.target.result;
                previewImage.classList.remove('hidden');
                placeholderText.classList.add('hidden');
                classifyButton.disabled = false;
                
                // Extract base64 part for the API call
                const base64Parts = e.target.result.split(',');
                if (base64Parts.length > 1) {
                    base64Image = base64Parts[1];
                }
            };
            reader.readAsDataURL(file);

            // Hide previous results
            resultsArea.classList.add('hidden');
            errorText.classList.add('hidden');
        };

        /**
         * Sets the loading state of the UI.
         * @param {boolean} isLoading - True to show loading, false otherwise.
         */
        function setLoading(isLoading) {
            classifyButton.disabled = isLoading || !base64Image;
            loadingIndicator.classList.toggle('hidden', !isLoading);
            buttonText.textContent = isLoading ? 'CLASSIFYING...' : 'CLASSIFY!';
        }

        /**
         * Cleans and parses the model's raw text response.
         * @param {string} rawText - The text response from the Gemini API.
         * @returns {{classification: string, confidence: string}}
         */
        function parseResponse(rawText) {
            const result = { classification: 'Unknown', confidence: '' };
            const cleanText = rawText.trim().replace(/['"]+/g, ''); // Remove quotes

            // Look for "Hot Dog" or "Not Hot Dog"
            if (cleanText.toLowerCase().includes('not hot dog')) {
                result.classification = 'Not Hot Dog';
            } else if (cleanText.toLowerCase().includes('hot dog')) {
                result.classification = 'Hot Dog';
            }

            // Look for confidence percentage
            const percentMatch = cleanText.match(/(\d+\.?\d*)\s*%/);
            if (percentMatch && percentMatch[0]) {
                result.confidence = percentMatch[0] + ' confidence';
            }

            return result;
        }

        /**
         * Displays the final classification result in the UI.
         * @param {string} classification - "Hot Dog" or "Not Hot Dog".
         * @param {string} confidence - The confidence percentage string.
         */
        window.displayResult = function(classification, confidence) { // Made global for potential external calls
            resultsArea.classList.remove('hidden');
            errorText.classList.add('hidden');

            // Set the result text to the exact bracketed format requested, ensure it's not nested
            resultText.textContent = `[CLASSIFICATION: ${classification.toUpperCase()}]`;
            confidenceText.textContent = confidence;
            
            // Apply styling based on classification
            if (classification.toLowerCase().includes('hot dog')) {
                resultsArea.className = 'min-h-[6rem] p-4 rounded-lg text-center transition-all duration-300 bg-green-100 ring-4 ring-green-500';
                resultText.className = 'text-3xl md:text-5xl font-extrabold text-green-700';
            } else if (classification.toLowerCase().includes('not hot dog')) {
                // Apply the bold red styling for "Not Hot Dog"
                resultsArea.className = 'min-h-[6rem] p-4 rounded-lg text-center transition-all duration-300 bg-red-100 ring-4 ring-red-500';
                resultText.className = 'text-3xl md:text-5xl font-extrabold text-red-700';
            } else {
                 // Unknown/Fallback state
                 resultsArea.className = 'min-h-[6rem] p-4 rounded-lg text-center transition-all duration-300 bg-gray-100 ring-4 ring-gray-500';
                 resultText.className = 'text-3xl md:text-5xl font-extrabold text-gray-700';
            }
        }

        /**
         * Displays an error message.
         * @param {string} message - The error message.
         */
        window.displayError = function(message) { // Made global for potential external calls
            resultsArea.classList.remove('hidden');
            resultsArea.className = 'min-h-[6rem] p-4 rounded-lg text-center bg-yellow-100 ring-4 ring-yellow-500';
            resultText.textContent = 'CLASSIFICATION FAILED';
            confidenceText.textContent = 'Please try another image.';
            errorText.textContent = message;
            errorText.classList.remove('hidden');
        }


        /**
         * Main function to call the Gemini API for image classification.
         */
        window.classifyImage = async function() {
            if (!base64Image) {
                displayError("No image selected for classification.");
                return;
            }
            if (!apiKey) {
                displayError("API Key is missing from the code! Please insert your key to proceed.");
                return;
            }

            setLoading(true);
            resultsArea.classList.add('hidden'); // Hide old results

            const mimeType = imageUpload.files[0].type || 'image/jpeg';
            
            const systemPrompt = "You are an image classification model specialized in determining if the main object in an image is a hot dog. Your response MUST strictly follow the format: [Classification: Hot Dog or Not Hot Dog], [Confidence: X% confidence]. Do not add any other text, greetings, or explanations.";
            const userQuery = "Classify the main subject of this image as 'Hot Dog' or 'Not Hot Dog' and provide the confidence score.";

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: userQuery },
                            {
                                inlineData: {
                                    mimeType: mimeType,
                                    data: base64Image
                                }
                            }
                        ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            
            // --- API Call with Exponential Backoff ---
            const maxRetries = 5;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const fullUrl = API_URL + apiKey;
                    const response = await fetch(fullUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry
                        }
                        if (response.status === 403) {
                             throw new Error(`HTTP error! status: 403. The API key may be invalid or restricted.`);
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    const textPart = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (textPart) {
                        const { classification, confidence } = parseResponse(textPart);
                        displayResult(classification, confidence);
                    } else {
                        throw new Error("API response was invalid or empty.");
                    }
                    
                    break; // Success, exit loop

                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error('Classification failed after multiple retries:', error);
                        displayError(`An error occurred: ${error.message}.`);
                    }
                }
            }
            
            setLoading(false);
        };

    </script>
</body>
</html>


